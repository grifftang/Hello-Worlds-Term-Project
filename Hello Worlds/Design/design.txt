—————————————————————————————————-——Hello Worlds Design———————————————————————————————————
	
	Many problems I address have to do with keeping track of objects and calculating velocities, accelerations, forces. To do this, my code is object-centric, where many objects, for example players, suns, end zones, etc. are fed into the main game class by means of lists. By using lists, the code is able to adapt to any sudden changes the player may make during the game or level creation. Relying solely on objects is impossible for Hello Worlds, as objects come and go very quickly. With lists, Hello Worlds is able to call the last ([-1]) object in a list, which will always be the newest, likely only addition to that list. Lists are extremely flexible because, if one is suddenly emptied mid loop, the code is able to detect that and call failsafe measures in order to safeguard itself against crashing. To address the algorithmic complexities of constantly changing velocities and directions, the code splits up forces into the x and y counterparts through trigonometry. Once the directions are separated, due to innate loss of information in trigonometry with even angles that must be manually changed to negative. So, to overcome this, the code sets up coordinates around the object the focus is rotating or gravitating around, and decides how to transform the x and y components of force or direction. By having each object able to do these calculations independently, Hello Worlds is able to make a lot of things happen in harmony.
	The GUI is designed in order to make the user experience as intuitive and obvious as possible. For example, when playing the game, the tool tips stay up for the first three tries per level, there is a help pop-up in any section of the game that may need it, and the flow of the menus is intended to work logically. I tried to adapt an arcade style through music and fonts, but a more contemporary approach with the features, such as the vector field display. I had a lot of fun trying to make the interface as appealing as possible, going as far as generating the stars recursively to make sure none are too close together. Using pygame, I was able to put a lot on the screen and make those things do a lot. A fun thing to do that I did to test my code, as well as pygame’s capabilities, is set the number of stars in the init function to 900, and the chance of twinkling to 2, as in 1/2. The result is a stunning swathe of sparkling with a spinning rocket calculating real-world based gravity, that is also independently rotating according to the direction of the greatest change in velocity, and very intensive fonts overlaid on top of that. You can even display a vector field on top of that too.
	To look at influences, I would like to think that this idea is in large part original. Because of this, the styles and inspirations for design are the space games and arcade games that I grew up with that left a subconscious impression.


—————————————————————————————————-—————————————————————-——————————————————————————————————

